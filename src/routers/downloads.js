const express = require('express');
const router = express.Router();
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs-extra');
const { getDb } = require('../db');

// --- MongoDB Counters Pattern for Sequential IDs ---
// In MongoDB Compass, run this once to initialize the counter:
// db.getCollection('downloads-id-counters').insertOne({ _id: 'postId', sequence_value: 0 })
async function getNextSequenceValue(sequenceName) {
  const db = getDb();
  const sequenceDocument = await db
    .collection('downloads-id-counters')
    .findOneAndUpdate(
      { _id: sequenceName },
      { $inc: { sequence_value: 1 } },
      { returnDocument: 'after', upsert: true },
    );
  return sequenceDocument.sequence_value;
}
// ----------------------------------------------------

// Ensure upload directory exists
const uploadDir = process.env.UPLOAD_DIR || 'uploads';
fs.ensureDirSync(uploadDir);

// Multer storage configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const newFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, newFilename);
  },
});

const upload = multer({ storage });

/**
 * [C] Create a new post with multiple file uploads
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 */
router.post('/', upload.array('files', 10), async (req, res) => {
  const { title, description } = req.body;
  const files = req.files;

  if (!title || !description || !files || files.length === 0) {
    return res
      .status(400)
      .json({ error: 'Title, description, and at least one file are required.' });
  }

  try {
    const db = getDb();
    const fileMetadata = files.map((file) => ({
      fileName: file.filename,
      originalName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      path: file.path,
    }));

    const newDownloadPost = {
      // _id is now auto-generated by MongoDB
      id: await getNextSequenceValue('postId'), // User-facing sequential ID
      title,
      description,
      files: fileMetadata,
      downloads: 0,
      createdAt: new Date(),
    };

    const result = await db.collection('downloads').insertOne(newDownloadPost);
    const createdPost = await db.collection('downloads').findOne({ _id: result.insertedId });
    res.status(201).json(createdPost);
  } catch (error) {
    console.error('Failed to create post:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

/**
 * [R] Get all download posts
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 */
router.get('/', async (req, res) => {
  try {
    const db = getDb();
    const posts = await db.collection('downloads').find({}).sort({ id: -1 }).toArray(); // Sort by user-facing ID
    res.json(posts);
  } catch (error) {
    console.error('Failed to get posts:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

/**
 * [R] Get a single download post by ID
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 */
router.get('/:id', async (req, res) => {
  try {
    const db = getDb();
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: 'Invalid ID format.' });
    }
    const item = await db.collection('downloads').findOne({ id: id }); // Find by user-facing ID
    if (!item) {
      return res.status(404).json({ error: 'Download post not found.' });
    }
    res.json(item);
  } catch (error) {
    console.error('Failed to get post:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

/**
 * [U] Update a download post by ID.
 * Can update metadata (title, description), add new files, and remove existing files.
 *
 * To update, the client sends a multipart/form-data request with:
 * - title (optional): The new title.
 * - description (optional): The new description.
 * - existingFiles (optional): A JSON string of an array of file metadata objects for files to keep.
 *   e.g., '[{"fileName":"...","originalName":"..."}, ...]'
 * - files (optional): New files to upload.
 */
router.put('/:id', upload.array('files', 10), async (req, res) => {
  try {
    const db = getDb();
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      if (req.files) {
        req.files.forEach((f) => fs.remove(f.path));
      }
      return res.status(400).json({ error: 'Invalid ID format.' });
    }

    const { title, description } = req.body;
    let filesToKeep = [];
    if (req.body.existingFiles) {
      try {
        filesToKeep = JSON.parse(req.body.existingFiles);
        if (!Array.isArray(filesToKeep)) {
          throw new Error('existingFiles is not an array.');
        }
      } catch (e) {
        if (req.files) {
          req.files.forEach((f) => fs.remove(f.path));
        }
        return res
          .status(400)
          .json({ error: 'Invalid format for existingFiles. It must be a JSON array string.' });
      }
    }

    const originalPost = await db.collection('downloads').findOne({ id });
    if (!originalPost) {
      if (req.files) {
        req.files.forEach((f) => fs.remove(f.path));
      }
      return res.status(404).json({ error: 'Download post not found.' });
    }

    // Identify and delete files that were removed by the client
    const filesToKeepSet = new Set(filesToKeep.map((f) => f.fileName));
    const filesToDelete = originalPost.files.filter((file) => !filesToKeepSet.has(file.fileName));

    const deletePromises = filesToDelete.map((file) => {
      if (file && file.path) {
        return fs
          .remove(file.path)
          .catch((err) => console.error(`Failed to delete old file: ${file.path}`, err));
      }
      return Promise.resolve();
    });
    await Promise.all(deletePromises);

    // Prepare metadata for newly uploaded files
    const newFileMetadata = (req.files || []).map((file) => ({
      fileName: file.filename,
      originalName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      path: file.path,
    }));

    // Combine kept files and new files
    const updatedFileMetadata = [...filesToKeep, ...newFileMetadata];

    // Prepare the update document for MongoDB
    const updateDoc = {
      $set: {},
    };
    if (title !== undefined) {
      updateDoc.$set.title = title;
    }
    if (description !== undefined) {
      updateDoc.$set.description = description;
    }
    if (updatedFileMetadata.length > 0 || filesToDelete.length > 0) {
      updateDoc.$set.files = updatedFileMetadata;
    }

    // To prevent setting empty `files` array if no files are provided at all
    if (
      req.files.length === 0 &&
      filesToKeep.length === 0 &&
      originalPost.files.length > 0 &&
      filesToDelete.length === originalPost.files.length
    ) {
      updateDoc.$set.files = [];
    }

    const result = await db
      .collection('downloads')
      .findOneAndUpdate({ id }, updateDoc, { returnDocument: 'after' });

    res.json(result);
  } catch (error) {
    console.error('Failed to update post:', error);
    // Clean up any uploaded files in case of a server error
    if (req.files) {
      req.files.forEach((f) => fs.remove(f.path));
    }
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

/**
 * [D] Delete a download post by ID, including all its files
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 */
router.delete('/:id', async (req, res) => {
  try {
    const db = getDb();
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ error: 'Invalid ID format.' });
    }

    const postToDelete = await db.collection('downloads').findOne({ id: id }); // Find by user-facing ID
    if (!postToDelete) {
      return res.status(404).json({ error: 'Download post not found.' });
    }

    const result = await db.collection('downloads').deleteOne({ id: id }); // Delete by user-facing ID
    if (result.deletedCount === 0) {
      // This case is unlikely if findOne succeeded, but good for safety
      return res.status(404).json({ error: 'Download post not found.' });
    }

    if (postToDelete.files) {
      postToDelete.files.forEach((file) => {
        if (file && file.path) {
          fs.remove(file.path).catch((err) =>
            console.error(`Failed to delete file: ${file.path}`, err),
          );
        }
      });
    }
    res.status(204).send();
  } catch (error) {
    console.error('Failed to delete post:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

module.exports = router;
